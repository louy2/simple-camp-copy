<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Ëê•Âú∞‰øùÂç´Êàò</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #000;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
}
canvas {
  display: block;
  margin: 0 auto;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
// ==================== CAMP DEFENSE GAME ====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- Responsive sizing ---
function resize() {
  const dpr = window.devicePixelRatio || 1;
  const w = window.innerWidth;
  const h = window.innerHeight;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', resize);

function getW() { return window.innerWidth; }
function getH() { return window.innerHeight; }

// --- Constants ---
const TILE_W = 64;   // diamond tile width (horizontal span)
const TILE_H = 38;   // diamond tile height (vertical span)
const GRID_COLS = 5;
const GRID_ROWS = 5;
let TOTAL_WAVES = 5;
const CAMP_COL = 2;
const CAMP_ROW = 2;
const MAX_LEVEL = 3;
// Upgrade costs per level (level 1‚Üí2, 2‚Üí3)
const UPGRADE_COSTS = [0, 20, 40]; // index = current level, value = cost to upgrade
// Stat multipliers per level [level1, level2, level3]
const LEVEL_DAMAGE_MULT  = [1, 1.5, 2.0];
const LEVEL_RANGE_MULT   = [1, 1.15, 1.3];
const LEVEL_ASPD_MULT    = [1, 1.2, 1.4];

// --- Level configurations ---
const LEVELS = [
  { id: 1, name: 'Êñ∞ÊâãËÆ≠ÁªÉ', desc: '3Ê≥¢ | ÂàùÂßã120Èáë', waves: 3, gold: 120, hpMult: 0.8, speedMult: 0.9, emoji: 'üå±' },
  { id: 2, name: 'Ê≤ôÊº†Ëê•Âú∞', desc: '5Ê≥¢ | ÂàùÂßã100Èáë', waves: 5, gold: 100, hpMult: 1.0, speedMult: 1.0, emoji: 'üèïÔ∏è' },
  { id: 3, name: 'ÂâçÁ∫øÈòµÂú∞', desc: '7Ê≥¢ | ÂàùÂßã80Èáë',  waves: 7, gold: 80,  hpMult: 1.2, speedMult: 1.1, emoji: '‚öîÔ∏è' },
  { id: 4, name: 'Ê≠ª‰∫°Â≥°Ë∞∑', desc: '10Ê≥¢ | ÂàùÂßã60Èáë', waves: 10, gold: 60, hpMult: 1.5, speedMult: 1.2, emoji: 'üíÄ' },
];

// --- Background themes ---
const BG_THEMES = [
  { id: 'desert',    name: 'Ê≤ôÊº†', emoji: 'üèúÔ∏è',
    gradient: ['#e8c878', '#dbb860', '#c9a84c'],
    waveColor: 'rgba(180, 140, 60, 0.3)',
    tileColors: { ring1: 'rgba(220, 190, 130, 0.6)', ring2: 'rgba(200, 170, 110, 0.5)',
                  ring1Alt: 'rgba(225, 195, 140, 0.6)', ring2Alt: 'rgba(210, 180, 120, 0.5)' },
    tileBorder: 'rgba(160, 130, 80, 0.5)',
    campTile: 'rgba(180, 140, 90, 0.7)', campBorder: 'rgba(140, 100, 60, 0.6)',
    decorations: 'desert' },
  { id: 'grassland', name: 'ËçâÂéü', emoji: 'üåø',
    gradient: ['#7ec850', '#5ba840', '#4a8a35'],
    waveColor: 'rgba(60, 120, 40, 0.25)',
    tileColors: { ring1: 'rgba(130, 200, 110, 0.6)', ring2: 'rgba(110, 180, 90, 0.5)',
                  ring1Alt: 'rgba(140, 210, 120, 0.6)', ring2Alt: 'rgba(120, 190, 100, 0.5)' },
    tileBorder: 'rgba(80, 130, 60, 0.5)',
    campTile: 'rgba(100, 160, 80, 0.7)', campBorder: 'rgba(70, 120, 50, 0.6)',
    decorations: 'grassland' },
  { id: 'snow',      name: 'Èõ™Âú∞', emoji: '‚ùÑÔ∏è',
    gradient: ['#d4e8f0', '#b8d4e4', '#9cc0d8'],
    waveColor: 'rgba(150, 180, 200, 0.25)',
    tileColors: { ring1: 'rgba(200, 220, 240, 0.6)', ring2: 'rgba(180, 200, 220, 0.5)',
                  ring1Alt: 'rgba(210, 230, 245, 0.6)', ring2Alt: 'rgba(190, 210, 230, 0.5)' },
    tileBorder: 'rgba(140, 160, 180, 0.5)',
    campTile: 'rgba(170, 195, 215, 0.7)', campBorder: 'rgba(130, 155, 175, 0.6)',
    decorations: 'snow' },
  { id: 'lava',      name: 'ÁÜîÂ≤©', emoji: 'üåã',
    gradient: ['#4a2020', '#3a1515', '#2a0e0e'],
    waveColor: 'rgba(200, 80, 30, 0.2)',
    tileColors: { ring1: 'rgba(120, 60, 40, 0.6)', ring2: 'rgba(100, 45, 30, 0.5)',
                  ring1Alt: 'rgba(130, 65, 45, 0.6)', ring2Alt: 'rgba(110, 50, 35, 0.5)' },
    tileBorder: 'rgba(180, 80, 40, 0.5)',
    campTile: 'rgba(140, 70, 40, 0.7)', campBorder: 'rgba(180, 90, 50, 0.6)',
    decorations: 'lava' },
];

let selectedLevel = null;   // index into LEVELS
let selectedBgTheme = 0;    // index into BG_THEMES
let currentLevel = LEVELS[1]; // default level config
let currentTheme = BG_THEMES[0]; // current background theme
let menuSelection = 'level'; // 'level' or 'background' tab on menu

// --- Isometric coordinate helpers ---
// Grid center on screen
function gridCenterX() { return getW() / 2; }
function gridCenterY() { return getH() / 2 - 50; }

// Convert grid (col, row) to screen (x, y) ‚Äî center of that diamond tile
function gridToScreen(col, row) {
  const dc = col - CAMP_COL;
  const dr = row - CAMP_ROW;
  return {
    x: gridCenterX() + (dc - dr) * TILE_W / 2,
    y: gridCenterY() + (dc + dr) * TILE_H / 2,
  };
}

// Convert screen (x, y) to grid (col, row) ‚Äî returns fractional, caller rounds
function screenToGrid(sx, sy) {
  const rx = sx - gridCenterX();
  const ry = sy - gridCenterY();
  const dc = rx / (TILE_W / 2) + ry / (TILE_H / 2);
  const dr = ry / (TILE_H / 2) - rx / (TILE_W / 2);
  return {
    col: Math.round(dc / 2 + CAMP_COL),
    row: Math.round(dr / 2 + CAMP_ROW),
  };
}

// Check if a grid cell is valid (within the 5x5 diamond)
function isValidCell(col, row) {
  return col >= 0 && col < GRID_COLS && row >= 0 && row < GRID_ROWS;
}

// Check if cell is the camp center
function isCampCell(col, row) {
  return col === CAMP_COL && row === CAMP_ROW;
}

// Get ring number: 0 = camp, 1 = inner ring, 2 = outer ring
function getCellRing(col, row) {
  const dc = Math.abs(col - CAMP_COL);
  const dr = Math.abs(row - CAMP_ROW);
  return Math.max(dc, dr);
}

// Draw a diamond tile path at screen center (cx, cy)
function diamondPath(cx, cy, inset) {
  const hw = TILE_W / 2 - inset;
  const hh = TILE_H / 2 - inset;
  ctx.beginPath();
  ctx.moveTo(cx, cy - hh);       // top
  ctx.lineTo(cx + hw, cy);       // right
  ctx.lineTo(cx, cy + hh);       // bottom
  ctx.lineTo(cx - hw, cy);       // left
  ctx.closePath();
}

// Point-in-diamond test
function pointInDiamond(px, py, cx, cy) {
  const dx = Math.abs(px - cx);
  const dy = Math.abs(py - cy);
  return (dx / (TILE_W / 2) + dy / (TILE_H / 2)) <= 1;
}

// --- Game state ---
let gold = 100;
let campHP = 100;
let campMaxHP = 100;
let wave = 0;
let waveActive = false;
let waveEnemiesSpawned = 0;
let waveEnemiesTotal = 0;
let gameSpeed = 1;
let gameState = 'menu'; // 'menu', 'playing', 'won', 'lost'
let selectedDefender = null;
let selectedPlacedDefender = null; // index into defenders[] for upgrade UI
let enemies = [];
let defenders = [];
let projectiles = [];
let particles = [];
let floatingTexts = [];
let spawnTimer = 0;
let waveDelay = 0;
let allWavesDone = false;

// --- Defender types ---
const DEFENDER_TYPES = [
  { id: 'archer',   name: 'ÂºìÁÆ≠Êâã', cost: 30,  color: '#4a7',  range: 120, damage: 8,  attackSpeed: 1.0, emoji: 'üèπ', desc: 'ËøúÁ®ãÊîªÂáª' },
  { id: 'warrior',  name: 'ÊàòÂ£´',   cost: 50,  color: '#c55',  range: 60,  damage: 15, attackSpeed: 0.8, emoji: '‚öîÔ∏è', desc: 'ËøëÊàòÈ´ò‰º§' },
  { id: 'mage',     name: 'Ê≥ïÂ∏à',   cost: 60,  color: '#66f',  range: 100, damage: 12, attackSpeed: 0.7, emoji: 'üîÆ', desc: 'ËåÉÂõ¥‰º§ÂÆ≥' },
  { id: 'healer',   name: 'Èõ™‰∫∫',   cost: 40,  color: '#aef',  range: 90,  damage: 5,  attackSpeed: 0.5, emoji: '‚õÑ', desc: 'ÂáèÈÄüÊïå‰∫∫' },
];

// Get effective stats for a defender considering its level
function getDefDamage(d) { return d.type.damage * LEVEL_DAMAGE_MULT[d.level - 1]; }
function getDefRange(d)  { return d.type.range  * LEVEL_RANGE_MULT[d.level - 1]; }
function getDefASpd(d)   { return d.type.attackSpeed * LEVEL_ASPD_MULT[d.level - 1]; }
function getUpgradeCost(d) { return d.level < MAX_LEVEL ? UPGRADE_COSTS[d.level] : -1; }

// --- Enemy types per wave ---
function getWaveEnemies(w) {
  return 4 + w * 2;
}

function createEnemy(w) {
  const hpM = currentLevel.hpMult;
  const spdM = currentLevel.speedMult;
  const types = [
    { name: 'Âè≤Ëé±ÂßÜ', hp: (30 + w*10)*hpM, speed: (0.6 + w*0.05)*spdM, color: '#6c3', reward: 10, size: 14, emoji: 'üü¢' },
    { name: 'ËùéÂ≠ê',   hp: (50 + w*15)*hpM, speed: (0.5 + w*0.04)*spdM, color: '#c93', reward: 15, size: 16, emoji: 'ü¶Ç' },
    { name: 'È™∑È´Ö',   hp: (80 + w*20)*hpM, speed: (0.4 + w*0.03)*spdM, color: '#ddd', reward: 20, size: 18, emoji: 'üíÄ' },
    { name: 'Boss',   hp: (200 + w*50)*hpM, speed: 0.3*spdM, color: '#f44', reward: 50, size: 24, emoji: 'üëπ' },
  ];
  let typeIdx = 0;
  if (w >= 2) typeIdx = Math.random() < 0.4 ? 1 : 0;
  if (w >= 3) typeIdx = Math.random() < 0.3 ? 2 : (Math.random() < 0.5 ? 1 : 0);
  if (w >= 4) typeIdx = Math.random() < 0.15 ? 3 : (Math.random() < 0.3 ? 2 : (Math.random() < 0.5 ? 1 : 0));
  const t = types[typeIdx];

  // Spawn from the 4 diamond-axis directions (top, right, bottom, left of diamond grid)
  const cx = gridCenterX();
  const cy = gridCenterY();
  const margin = 80;
  const side = Math.floor(Math.random() * 4);
  let x, y;
  // Outer corners of the diamond grid
  const topPos   = gridToScreen(0, 0);
  const rightPos = gridToScreen(4, 0);
  const botPos   = gridToScreen(4, 4);
  const leftPos  = gridToScreen(0, 4);
  const spread = 60;
  if (side === 0) { // top
    x = topPos.x + (Math.random() - 0.5) * spread;
    y = topPos.y - margin;
  } else if (side === 1) { // right
    x = rightPos.x + margin;
    y = rightPos.y + (Math.random() - 0.5) * spread;
  } else if (side === 2) { // bottom
    x = botPos.x + (Math.random() - 0.5) * spread;
    y = botPos.y + margin;
  } else { // left
    x = leftPos.x - margin;
    y = leftPos.y + (Math.random() - 0.5) * spread;
  }

  return {
    x, y, hp: t.hp, maxHP: t.hp, speed: t.speed, color: t.color,
    reward: t.reward, size: t.size, emoji: t.emoji, name: t.name,
    slowTimer: 0, slowFactor: 1,
    targetX: cx, targetY: cy,
  };
}

// --- Input handling ---
canvas.addEventListener('pointerdown', (e) => {
  handleTap({ x: e.clientX, y: e.clientY });
});

function getUpgradeBtn() {
  if (selectedPlacedDefender === null) return null;
  const d = defenders[selectedPlacedDefender];
  if (!d) return null;
  const w = 80, h = 30;
  return { x: d.x - w / 2, y: d.y - 52, w, h };
}

function handleTap(pos) {
  // Menu screen interactions
  if (gameState === 'menu') {
    handleMenuTap(pos);
    return;
  }

  if (gameState === 'won' || gameState === 'lost') {
    goToMenu();
    return;
  }

  // Back to menu button (top-left area)
  const menuBtn = getMenuBtn();
  if (pos.x >= menuBtn.x && pos.x <= menuBtn.x + menuBtn.w && pos.y >= menuBtn.y && pos.y <= menuBtn.y + menuBtn.h) {
    goToMenu();
    return;
  }

  // Check speed buttons
  const speedBtns = getSpeedButtons();
  for (const btn of speedBtns) {
    if (pos.x >= btn.x && pos.x <= btn.x + btn.w && pos.y >= btn.y && pos.y <= btn.y + btn.h) {
      gameSpeed = btn.speed;
      return;
    }
  }

  // Check start wave button
  if (!waveActive && wave < TOTAL_WAVES) {
    const btnInfo = getStartWaveBtn();
    if (pos.x >= btnInfo.x && pos.x <= btnInfo.x + btnInfo.w && pos.y >= btnInfo.y && pos.y <= btnInfo.y + btnInfo.h) {
      startNextWave();
      return;
    }
  }

  // Check upgrade button click
  if (selectedPlacedDefender !== null) {
    const ubtn = getUpgradeBtn();
    if (ubtn && pos.x >= ubtn.x && pos.x <= ubtn.x + ubtn.w && pos.y >= ubtn.y && pos.y <= ubtn.y + ubtn.h) {
      const d = defenders[selectedPlacedDefender];
      const cost = getUpgradeCost(d);
      if (cost >= 0 && gold >= cost) {
        gold -= cost;
        d.level++;
        spawnParticles(d.x, d.y, '#ff0', 10);
        saveGame();
      }
      return;
    }
  }

  // Check defender card selection
  const cards = getDefenderCards();
  for (let i = 0; i < cards.length; i++) {
    const c = cards[i];
    if (pos.x >= c.x && pos.x <= c.x + c.w && pos.y >= c.y && pos.y <= c.y + c.h) {
      selectedPlacedDefender = null;
      if (gold >= DEFENDER_TYPES[i].cost) {
        selectedDefender = (selectedDefender === i) ? null : i;
      }
      return;
    }
  }

  // Check grid tile click ‚Äî find which diamond tile was tapped
  let hitCol = -1, hitRow = -1;
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      if (isCampCell(c, r)) continue;
      const sc = gridToScreen(c, r);
      if (pointInDiamond(pos.x, pos.y, sc.x, sc.y)) {
        hitCol = c; hitRow = r;
      }
    }
  }

  if (hitCol >= 0 && hitRow >= 0) {
    // Check if tapping an existing defender to select it
    const defIdx = defenders.findIndex(d => d.col === hitCol && d.row === hitRow);
    if (defIdx >= 0 && selectedDefender === null) {
      // Toggle selection of this placed defender
      selectedPlacedDefender = (selectedPlacedDefender === defIdx) ? null : defIdx;
      return;
    }

    // Place new defender if a card is selected
    if (selectedDefender !== null && defIdx < 0) {
      const dt = DEFENDER_TYPES[selectedDefender];
      if (gold >= dt.cost) {
        gold -= dt.cost;
        const sc = gridToScreen(hitCol, hitRow);
        defenders.push({
          col: hitCol, row: hitRow,
          x: sc.x, y: sc.y,
          type: dt,
          level: 1,
          attackTimer: 0,
          angle: 0,
        });
        selectedDefender = null;
        saveGame();
      }
      return;
    }
  }

  // Tap elsewhere to deselect
  selectedDefender = null;
  selectedPlacedDefender = null;
}

// --- UI Layout helpers ---
function getSpeedButtons() {
  const w = 44, h = 28, gap = 8;
  const baseX = getW() - (w * 3 + gap * 2) - 10;
  const baseY = 8;
  return [
    { x: baseX, y: baseY, w, h, speed: 1, label: 'x1' },
    { x: baseX + w + gap, y: baseY, w, h, speed: 1.5, label: 'x1.5' },
    { x: baseX + (w + gap) * 2, y: baseY, w, h, speed: 2, label: 'x2' },
  ];
}

function getStartWaveBtn() {
  const w = 120, h = 36;
  return { x: (getW() - w) / 2, y: getH() - 140, w, h };
}

function getDefenderCards() {
  const cardW = 64, cardH = 80, gap = 8;
  const totalW = DEFENDER_TYPES.length * cardW + (DEFENDER_TYPES.length - 1) * gap;
  const baseX = (getW() - totalW) / 2;
  const baseY = getH() - 95;
  return DEFENDER_TYPES.map((_, i) => ({
    x: baseX + i * (cardW + gap),
    y: baseY,
    w: cardW,
    h: cardH,
  }));
}

// --- Game logic ---
function startNextWave() {
  wave++;
  waveActive = true;
  waveEnemiesSpawned = 0;
  waveEnemiesTotal = getWaveEnemies(wave);
  spawnTimer = 0;
  saveGame();
}

function update(dt) {
  if (gameState !== 'playing') return;
  dt *= gameSpeed;

  // Spawn enemies
  if (waveActive && waveEnemiesSpawned < waveEnemiesTotal) {
    spawnTimer -= dt;
    if (spawnTimer <= 0) {
      enemies.push(createEnemy(wave));
      waveEnemiesSpawned++;
      spawnTimer = 1.0 + Math.random() * 0.5;
    }
  }

  // Check wave end
  if (waveActive && waveEnemiesSpawned >= waveEnemiesTotal && enemies.length === 0) {
    waveActive = false;
    if (wave >= TOTAL_WAVES) {
      allWavesDone = true;
      gameState = 'won';
    }
    saveGame();
  }

  // Move enemies toward camp center
  const campX = gridCenterX();
  const campY = gridCenterY();
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.slowTimer > 0) { e.slowTimer -= dt; } else { e.slowFactor = 1; }
    const dx = campX - e.x;
    const dy = campY - e.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 20) {
      campHP -= 10;
      spawnParticles(e.x, e.y, '#f44', 5);
      enemies.splice(i, 1);
      if (campHP <= 0) { campHP = 0; gameState = 'lost'; saveGame(); }
      continue;
    }
    const spd = e.speed * e.slowFactor * 60 * dt;
    e.x += (dx / dist) * spd;
    e.y += (dy / dist) * spd;
  }

  // Defenders attack
  for (const d of defenders) {
    d.attackTimer -= dt;
    if (d.attackTimer <= 0) {
      const range = getDefRange(d);
      const damage = getDefDamage(d);
      const aspd = getDefASpd(d);
      let nearest = null, nearDist = Infinity;
      for (const e of enemies) {
        const dx = e.x - d.x, dy = e.y - d.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= range && dist < nearDist) {
          nearest = e; nearDist = dist;
        }
      }
      if (nearest) {
        d.attackTimer = 1 / aspd;
        d.angle = Math.atan2(nearest.y - d.y, nearest.x - d.x);
        if (d.type.id === 'mage') {
          for (const e of enemies) {
            const dx = e.x - nearest.x, dy = e.y - nearest.y;
            if (Math.sqrt(dx * dx + dy * dy) < 50) {
              e.hp -= damage;
            }
          }
          spawnParticles(nearest.x, nearest.y, '#66f', 8);
        } else if (d.type.id === 'healer') {
          nearest.hp -= damage;
          nearest.slowFactor = 0.4;
          nearest.slowTimer = 2.0;
          spawnParticles(nearest.x, nearest.y, '#aef', 4);
        } else {
          projectiles.push({
            x: d.x, y: d.y,
            tx: nearest.x, ty: nearest.y,
            target: nearest,
            speed: 250,
            damage: damage,
            color: d.type.color,
          });
        }
      }
    }
  }

  // Move projectiles
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    if (p.target && p.target.hp > 0) {
      p.tx = p.target.x; p.ty = p.target.y;
    }
    const dx = p.tx - p.x, dy = p.ty - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 8) {
      if (p.target && p.target.hp > 0) {
        p.target.hp -= p.damage;
        spawnParticles(p.tx, p.ty, p.color, 3);
      }
      projectiles.splice(i, 1);
      continue;
    }
    const spd = p.speed * dt;
    p.x += (dx / dist) * spd;
    p.y += (dy / dist) * spd;
  }

  // Remove dead enemies + give gold
  for (let i = enemies.length - 1; i >= 0; i--) {
    if (enemies[i].hp <= 0) {
      gold += enemies[i].reward;
      spawnParticles(enemies[i].x, enemies[i].y, '#ff0', 6);
      floatingTexts.push({
        x: enemies[i].x,
        y: enemies[i].y,
        text: '+' + enemies[i].reward + ' üí∞',
        life: 1.0,
        maxLife: 1.0,
      });
      enemies.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Update floating texts
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.y -= 40 * dt; // float upward
    ft.life -= dt;
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }

  // Auto-save periodically
  saveTimer += dt;
  if (saveTimer >= SAVE_INTERVAL) {
    saveTimer = 0;
    saveGame();
  }
}

function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 100,
      vy: (Math.random() - 0.5) * 100,
      life: 0.4 + Math.random() * 0.3,
      maxLife: 0.5,
      color,
    });
  }
}

// --- Drawing ---
function draw() {
  const W = getW(), H = getH();
  ctx.clearRect(0, 0, W, H);

  if (gameState === 'menu') {
    drawMenu();
    return;
  }

  drawBackground(W, H);
  drawGrid();
  drawCamp();
  drawDefenders();
  drawEnemies();
  drawProjectiles();
  drawParticles();
  drawFloatingTexts();
  drawUI(W, H);

  if (gameState === 'won') drawEndScreen('ËÉú Âà©ÔºÅ', '#4f4', 'Ëê•Âú∞ÂÆâÂÖ®‰∫ÜÔºÅ');
  if (gameState === 'lost') drawEndScreen('Â§± Ë¥•', '#f44', 'Ëê•Âú∞Ë¢´ÊëßÊØÅ‰∫Ü...');
}

function getMenuBtn() {
  return { x: 8, y: 6, w: 36, h: 28 };
}

function goToMenu() {
  gameState = 'menu';
  selectedLevel = null;
  clearSave();
}

// --- Menu tap handling ---
function handleMenuTap(pos) {
  const W = getW(), H = getH();
  const centerX = W / 2;

  // Tab buttons
  const tabW = 100, tabH = 36, tabGap = 16;
  const tabY = 80;
  const levelTabX = centerX - tabW - tabGap / 2;
  const bgTabX = centerX + tabGap / 2;

  if (pos.y >= tabY && pos.y <= tabY + tabH) {
    if (pos.x >= levelTabX && pos.x <= levelTabX + tabW) {
      menuSelection = 'level';
      return;
    }
    if (pos.x >= bgTabX && pos.x <= bgTabX + tabW) {
      menuSelection = 'background';
      return;
    }
  }

  if (menuSelection === 'level') {
    // Level cards
    const cardW = 160, cardH = 72, cardGap = 12;
    const totalH = LEVELS.length * (cardH + cardGap) - cardGap;
    const startY = 140;
    for (let i = 0; i < LEVELS.length; i++) {
      const cx = centerX - cardW / 2;
      const cy = startY + i * (cardH + cardGap);
      if (pos.x >= cx && pos.x <= cx + cardW && pos.y >= cy && pos.y <= cy + cardH) {
        selectedLevel = i;
        currentLevel = LEVELS[i];
        TOTAL_WAVES = currentLevel.waves;
        startGameFromMenu();
        return;
      }
    }
  } else {
    // Background theme cards
    const cardW = 140, cardH = 60, cardGap = 12;
    const startY = 140;
    for (let i = 0; i < BG_THEMES.length; i++) {
      const cx = centerX - cardW / 2;
      const cy = startY + i * (cardH + cardGap);
      if (pos.x >= cx && pos.x <= cx + cardW && pos.y >= cy && pos.y <= cy + cardH) {
        selectedBgTheme = i;
        currentTheme = BG_THEMES[i];
        return;
      }
    }
  }
}

function startGameFromMenu() {
  gold = currentLevel.gold;
  campHP = 100;
  campMaxHP = 100;
  wave = 0;
  waveActive = false;
  gameSpeed = 1;
  gameState = 'playing';
  selectedDefender = null;
  selectedPlacedDefender = null;
  enemies = [];
  defenders = [];
  projectiles = [];
  particles = [];
  floatingTexts = [];
  allWavesDone = false;
  TOTAL_WAVES = currentLevel.waves;
  clearSave();
}

// --- Draw Menu ---
function drawMenu() {
  const W = getW(), H = getH();

  // Background
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1a1a2e');
  grad.addColorStop(0.5, '#16213e');
  grad.addColorStop(1, '#0f3460');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Animated dots
  const time = Date.now() / 1000;
  for (let i = 0; i < 20; i++) {
    const x = (i * 97 + time * 15) % W;
    const y = (i * 61 + Math.sin(time + i) * 20) % H;
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath();
    ctx.arc(x, y, 2, 0, Math.PI * 2);
    ctx.fill();
  }

  const centerX = W / 2;

  // Title
  ctx.font = 'bold 32px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fd0';
  ctx.fillText('Ëê•Âú∞‰øùÂç´Êàò', centerX, 40);

  // Tab buttons
  const tabW = 100, tabH = 36, tabGap = 16;
  const tabY = 80;
  const levelTabX = centerX - tabW - tabGap / 2;
  const bgTabX = centerX + tabGap / 2;

  // Level tab
  ctx.fillStyle = menuSelection === 'level' ? 'rgba(255,200,50,0.7)' : 'rgba(255,255,255,0.15)';
  roundRect(ctx, levelTabX, tabY, tabW, tabH, 8);
  ctx.fill();
  ctx.font = 'bold 15px sans-serif';
  ctx.fillStyle = menuSelection === 'level' ? '#000' : '#ccc';
  ctx.fillText('ÈÄâÊã©ÂÖ≥Âç°', levelTabX + tabW / 2, tabY + tabH / 2);

  // Background tab
  ctx.fillStyle = menuSelection === 'background' ? 'rgba(255,200,50,0.7)' : 'rgba(255,255,255,0.15)';
  roundRect(ctx, bgTabX, tabY, tabW, tabH, 8);
  ctx.fill();
  ctx.fillStyle = menuSelection === 'background' ? '#000' : '#ccc';
  ctx.fillText('ÈÄâÊã©ËÉåÊôØ', bgTabX + tabW / 2, tabY + tabH / 2);

  if (menuSelection === 'level') {
    drawLevelSelect(W, H, centerX);
  } else {
    drawBgSelect(W, H, centerX);
  }
}

function drawLevelSelect(W, H, centerX) {
  const cardW = 160, cardH = 72, cardGap = 12;
  const startY = 140;

  for (let i = 0; i < LEVELS.length; i++) {
    const lv = LEVELS[i];
    const cx = centerX - cardW / 2;
    const cy = startY + i * (cardH + cardGap);

    // Card background
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    roundRect(ctx, cx, cy, cardW, cardH, 10);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 1;
    roundRect(ctx, cx, cy, cardW, cardH, 10);
    ctx.stroke();

    // Emoji
    ctx.font = '28px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(lv.emoji, cx + 30, cy + cardH / 2);

    // Level name
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#fff';
    ctx.fillText(lv.name, cx + 55, cy + 24);

    // Description
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#aaa';
    ctx.fillText(lv.desc, cx + 55, cy + 48);
  }

  // Hint
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fillText('ÁÇπÂáªÂÖ≥Âç°ÂºÄÂßãÊ∏∏Êàè', centerX, startY + LEVELS.length * (cardH + cardGap) + 16);
}

function drawBgSelect(W, H, centerX) {
  const cardW = 140, cardH = 60, cardGap = 12;
  const startY = 140;

  for (let i = 0; i < BG_THEMES.length; i++) {
    const bg = BG_THEMES[i];
    const cx = centerX - cardW / 2;
    const cy = startY + i * (cardH + cardGap);
    const isSelected = selectedBgTheme === i;

    // Card background with theme preview gradient
    const cGrad = ctx.createLinearGradient(cx, cy, cx + cardW, cy);
    cGrad.addColorStop(0, bg.gradient[0]);
    cGrad.addColorStop(1, bg.gradient[2]);
    ctx.fillStyle = cGrad;
    roundRect(ctx, cx, cy, cardW, cardH, 10);
    ctx.fill();

    // Darken overlay for readability
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    roundRect(ctx, cx, cy, cardW, cardH, 10);
    ctx.fill();

    // Selection border
    ctx.strokeStyle = isSelected ? '#fd0' : 'rgba(255,255,255,0.2)';
    ctx.lineWidth = isSelected ? 2.5 : 1;
    roundRect(ctx, cx, cy, cardW, cardH, 10);
    ctx.stroke();

    // Emoji + name
    ctx.font = '22px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(bg.emoji, cx + 30, cy + cardH / 2);

    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#fff';
    ctx.fillText(bg.name, cx + 55, cy + cardH / 2);

    // Checkmark for selected
    if (isSelected) {
      ctx.font = 'bold 18px sans-serif';
      ctx.textAlign = 'right';
      ctx.fillStyle = '#fd0';
      ctx.fillText('‚úì', cx + cardW - 12, cy + cardH / 2);
    }
  }

  // Hint
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fillText('ÈÄâÊã©ËÉåÊôØÂêéÂàáÊç¢Âà∞"ÈÄâÊã©ÂÖ≥Âç°"ÂºÄÂßã', centerX, startY + BG_THEMES.length * (cardH + cardGap) + 16);
}

function drawBackground(W, H) {
  const theme = currentTheme;

  // Background gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, theme.gradient[0]);
  grad.addColorStop(0.5, theme.gradient[1]);
  grad.addColorStop(1, theme.gradient[2]);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Wave pattern
  ctx.strokeStyle = theme.waveColor;
  ctx.lineWidth = 1.5;
  for (let i = 0; i < 8; i++) {
    ctx.beginPath();
    const yOff = 50 + i * 55;
    for (let x = 0; x <= W; x += 5) {
      const y = yOff + Math.sin(x * 0.015 + i * 1.5) * 12 + Math.sin(x * 0.008 + i) * 8;
      if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  // Decorative elements based on theme
  const topPos   = gridToScreen(0, 0);
  const rightPos = gridToScreen(4, 0);
  const botPos   = gridToScreen(4, 4);
  const leftPos  = gridToScreen(0, 4);

  if (theme.decorations === 'desert') {
    drawCactus(leftPos.x - 30, leftPos.y + 10);
    drawCactus(rightPos.x + 25, rightPos.y + 15);
    drawDeadTree(rightPos.x + 15, topPos.y - 20);
    drawPineTree(leftPos.x - 25, topPos.y + 10);
  } else if (theme.decorations === 'grassland') {
    drawFlower(leftPos.x - 30, leftPos.y + 10);
    drawFlower(rightPos.x + 25, rightPos.y + 15);
    drawPineTree(rightPos.x + 15, topPos.y - 20);
    drawPineTree(leftPos.x - 25, topPos.y + 10);
    drawBush(botPos.x + 20, botPos.y - 10);
  } else if (theme.decorations === 'snow') {
    drawSnowTree(leftPos.x - 30, leftPos.y + 10);
    drawSnowTree(rightPos.x + 25, rightPos.y + 15);
    drawSnowman(rightPos.x + 15, topPos.y - 10);
    drawSnowTree(leftPos.x - 25, topPos.y + 10);
  } else if (theme.decorations === 'lava') {
    drawLavaRock(leftPos.x - 30, leftPos.y + 10);
    drawLavaRock(rightPos.x + 25, rightPos.y + 15);
    drawLavaCrack(rightPos.x + 15, topPos.y - 10);
    drawLavaRock(leftPos.x - 25, topPos.y + 10);
  }
}

function drawCactus(x, y) {
  ctx.fillStyle = '#5a4';
  ctx.fillRect(x - 4, y - 30, 8, 35);
  ctx.fillRect(x - 4, y - 20, -10, 6);
  ctx.fillRect(x - 14, y - 30, 6, 16);
  ctx.fillRect(x + 4, y - 15, 10, 6);
  ctx.fillRect(x + 8, y - 25, 6, 16);
}

function drawDeadTree(x, y) {
  ctx.strokeStyle = '#8b6';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(x, y + 20); ctx.lineTo(x, y - 15); ctx.stroke();
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, y - 5); ctx.lineTo(x - 12, y - 20); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x, y - 10); ctx.lineTo(x + 10, y - 25); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 8, y - 12); ctx.stroke();
}

function drawPineTree(x, y) {
  ctx.fillStyle = '#396';
  ctx.beginPath(); ctx.moveTo(x, y - 30); ctx.lineTo(x - 14, y); ctx.lineTo(x + 14, y); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(x, y - 22); ctx.lineTo(x - 11, y - 5); ctx.lineTo(x + 11, y - 5); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#743';
  ctx.fillRect(x - 3, y, 6, 8);
}

// --- Grassland decorations ---
function drawFlower(x, y) {
  // Stem
  ctx.strokeStyle = '#396';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, y + 5); ctx.lineTo(x, y - 15); ctx.stroke();
  // Petals
  const colors = ['#f66', '#ff6', '#f6f', '#6cf'];
  const c = colors[Math.floor(Math.abs(x * y)) % colors.length];
  ctx.fillStyle = c;
  for (let a = 0; a < 5; a++) {
    const angle = (a / 5) * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(x + Math.cos(angle) * 6, y - 15 + Math.sin(angle) * 6, 3, 0, Math.PI * 2);
    ctx.fill();
  }
  // Center
  ctx.fillStyle = '#fd0';
  ctx.beginPath(); ctx.arc(x, y - 15, 3, 0, Math.PI * 2); ctx.fill();
}

function drawBush(x, y) {
  ctx.fillStyle = '#4a8';
  ctx.beginPath(); ctx.arc(x, y, 12, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x - 8, y + 2, 9, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + 8, y + 2, 9, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#5b9';
  ctx.beginPath(); ctx.arc(x, y - 3, 6, 0, Math.PI * 2); ctx.fill();
}

// --- Snow decorations ---
function drawSnowTree(x, y) {
  // Trunk
  ctx.fillStyle = '#654';
  ctx.fillRect(x - 3, y, 6, 10);
  // Snow-covered foliage
  ctx.fillStyle = '#6a9';
  ctx.beginPath(); ctx.moveTo(x, y - 30); ctx.lineTo(x - 14, y); ctx.lineTo(x + 14, y); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#7ba';
  ctx.beginPath(); ctx.moveTo(x, y - 22); ctx.lineTo(x - 11, y - 5); ctx.lineTo(x + 11, y - 5); ctx.closePath(); ctx.fill();
  // Snow caps
  ctx.fillStyle = '#eef';
  ctx.beginPath(); ctx.moveTo(x, y - 30); ctx.lineTo(x - 7, y - 18); ctx.lineTo(x + 7, y - 18); ctx.closePath(); ctx.fill();
}

function drawSnowman(x, y) {
  ctx.fillStyle = '#eef';
  ctx.beginPath(); ctx.arc(x, y + 8, 10, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x, y - 5, 7, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x, y - 15, 5, 0, Math.PI * 2); ctx.fill();
  // Eyes
  ctx.fillStyle = '#333';
  ctx.beginPath(); ctx.arc(x - 2, y - 16, 1, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + 2, y - 16, 1, 0, Math.PI * 2); ctx.fill();
  // Nose
  ctx.fillStyle = '#f80';
  ctx.beginPath(); ctx.moveTo(x, y - 14); ctx.lineTo(x + 6, y - 13); ctx.lineTo(x, y - 12); ctx.closePath(); ctx.fill();
}

// --- Lava decorations ---
function drawLavaRock(x, y) {
  ctx.fillStyle = '#444';
  ctx.beginPath();
  ctx.moveTo(x - 10, y + 5);
  ctx.lineTo(x - 6, y - 15);
  ctx.lineTo(x + 2, y - 18);
  ctx.lineTo(x + 10, y - 8);
  ctx.lineTo(x + 8, y + 5);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#555';
  ctx.beginPath();
  ctx.moveTo(x - 4, y - 12);
  ctx.lineTo(x + 1, y - 16);
  ctx.lineTo(x + 8, y - 6);
  ctx.lineTo(x + 2, y - 5);
  ctx.closePath();
  ctx.fill();
}

function drawLavaCrack(x, y) {
  ctx.strokeStyle = '#f62';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x - 8, y - 10);
  ctx.lineTo(x - 2, y);
  ctx.lineTo(x + 5, y - 5);
  ctx.lineTo(x + 10, y + 8);
  ctx.stroke();
  // Glow
  ctx.strokeStyle = 'rgba(255, 100, 20, 0.4)';
  ctx.lineWidth = 5;
  ctx.beginPath();
  ctx.moveTo(x - 8, y - 10);
  ctx.lineTo(x - 2, y);
  ctx.lineTo(x + 5, y - 5);
  ctx.lineTo(x + 10, y + 8);
  ctx.stroke();
  ctx.lineWidth = 1;
}

function drawGrid() {
  const theme = currentTheme;
  // Draw tiles from back to front (top to bottom in isometric order)
  for (let r = 0; r < GRID_ROWS; r++) {
    for (let c = 0; c < GRID_COLS; c++) {
      if (isCampCell(c, r)) continue; // camp drawn separately
      const sc = gridToScreen(c, r);
      const ring = getCellRing(c, r);

      // Tile fill ‚Äî different shade per ring, using theme colors
      if (ring === 1) {
        ctx.fillStyle = theme.tileColors.ring1;
      } else {
        ctx.fillStyle = theme.tileColors.ring2;
      }
      // Alternate tint
      if ((r + c) % 2 === 0) {
        ctx.fillStyle = ring === 1 ? theme.tileColors.ring1Alt : theme.tileColors.ring2Alt;
      }

      diamondPath(sc.x, sc.y, 1);
      ctx.fill();

      // Highlight placeable tiles when defender selected
      if (selectedDefender !== null) {
        const occupied = defenders.some(d => d.col === c && d.row === r);
        if (!occupied) {
          ctx.fillStyle = 'rgba(100, 255, 100, 0.2)';
          diamondPath(sc.x, sc.y, 1);
          ctx.fill();
        }
      }

      // Tile border
      ctx.strokeStyle = theme.tileBorder;
      ctx.lineWidth = 1;
      diamondPath(sc.x, sc.y, 1);
      ctx.stroke();
    }
  }
}

function drawCamp() {
  const sc = gridToScreen(CAMP_COL, CAMP_ROW);
  const cx = sc.x, cy = sc.y;

  // Draw camp diamond tile
  ctx.fillStyle = currentTheme.campTile;
  diamondPath(cx, cy, 1);
  ctx.fill();
  ctx.strokeStyle = currentTheme.campBorder;
  ctx.lineWidth = 1.5;
  diamondPath(cx, cy, 1);
  ctx.stroke();

  // Tent body
  ctx.fillStyle = '#c96';
  ctx.beginPath();
  ctx.moveTo(cx, cy - 22);
  ctx.lineTo(cx - 24, cy + 10);
  ctx.lineTo(cx + 24, cy + 10);
  ctx.closePath();
  ctx.fill();

  // Tent opening
  ctx.fillStyle = '#743';
  ctx.beginPath();
  ctx.moveTo(cx, cy - 5);
  ctx.lineTo(cx - 8, cy + 10);
  ctx.lineTo(cx + 8, cy + 10);
  ctx.closePath();
  ctx.fill();

  // Tent pole
  ctx.strokeStyle = '#965';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(cx, cy - 22); ctx.lineTo(cx, cy - 28); ctx.stroke();

  // Flag
  ctx.fillStyle = '#e44';
  ctx.beginPath();
  ctx.moveTo(cx, cy - 28);
  ctx.lineTo(cx + 10, cy - 25);
  ctx.lineTo(cx, cy - 22);
  ctx.closePath();
  ctx.fill();

  // HP bar
  const barW = 40, barH = 5;
  const hpRatio = campHP / campMaxHP;
  ctx.fillStyle = '#400';
  ctx.fillRect(cx - barW/2, cy - 34, barW, barH);
  ctx.fillStyle = hpRatio > 0.5 ? '#4c4' : (hpRatio > 0.25 ? '#cc4' : '#c44');
  ctx.fillRect(cx - barW/2, cy - 34, barW * hpRatio, barH);
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.strokeRect(cx - barW/2, cy - 34, barW, barH);
}

function drawDefenders() {
  for (let i = 0; i < defenders.length; i++) {
    const d = defenders[i];
    const x = d.x, y = d.y;
    const isSelected = (selectedPlacedDefender === i);

    // Selection highlight ring
    if (isSelected) {
      ctx.strokeStyle = 'rgba(255,220,50,0.7)';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(x, y, 20, 0, Math.PI * 2);
      ctx.stroke();

      // Range indicator for selected defender
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(x, y, getDefRange(d), 0, Math.PI * 2);
      ctx.stroke();
    }

    // Body circle
    ctx.fillStyle = d.type.color;
    ctx.beginPath();
    ctx.arc(x, y, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Emoji
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(d.type.emoji, x, y + 1);

    // Level stars
    if (d.level >= 2) {
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fd0';
      const stars = '‚≠ê'.repeat(d.level - 1);
      ctx.fillText(stars, x, y + 20);
    }

    // Range indicator when a defender card is selected
    if (selectedDefender !== null && !isSelected) {
      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(x, y, getDefRange(d), 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  // Draw upgrade button for selected placed defender
  if (selectedPlacedDefender !== null && defenders[selectedPlacedDefender]) {
    const d = defenders[selectedPlacedDefender];
    const ubtn = getUpgradeBtn();
    if (ubtn && d.level < MAX_LEVEL) {
      const cost = getUpgradeCost(d);
      const canAfford = gold >= cost;

      // Button background
      ctx.fillStyle = canAfford ? 'rgba(50,180,50,0.85)' : 'rgba(100,100,100,0.7)';
      roundRect(ctx, ubtn.x, ubtn.y, ubtn.w, ubtn.h, 6);
      ctx.fill();
      ctx.strokeStyle = canAfford ? 'rgba(255,255,255,0.5)' : 'rgba(150,150,150,0.4)';
      ctx.lineWidth = 1;
      roundRect(ctx, ubtn.x, ubtn.y, ubtn.w, ubtn.h, 6);
      ctx.stroke();

      // Button text
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = canAfford ? '#fff' : '#aaa';
      ctx.fillText('ÂçáÁ∫ß üí∞' + cost, ubtn.x + ubtn.w / 2, ubtn.y + ubtn.h / 2);
    } else if (d.level >= MAX_LEVEL) {
      // Show MAX label
      ctx.font = 'bold 11px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#fd0';
      ctx.fillText('MAX', d.x, d.y - 46);
    }

    // Show stat info below the defender
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    const infoW = 90, infoH = 36;
    const infoX = d.x - infoW / 2, infoY = d.y + 26;
    roundRect(ctx, infoX, infoY, infoW, infoH, 4);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('ÊîªÂáª:' + Math.round(getDefDamage(d)), infoX + 4, infoY + 11);
    ctx.fillText('Â∞ÑÁ®ã:' + Math.round(getDefRange(d)), infoX + 4, infoY + 24);
    ctx.textAlign = 'right';
    ctx.fillText('ÊîªÈÄü:' + getDefASpd(d).toFixed(1), infoX + infoW - 4, infoY + 11);
    ctx.fillText('Lv.' + d.level, infoX + infoW - 4, infoY + 24);
  }
}

function drawEnemies() {
  for (const e of enemies) {
    const x = e.x, y = e.y;
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(x, y + e.size * 0.6, e.size * 0.7, e.size * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Body
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.arc(x, y, e.size, 0, Math.PI * 2);
    ctx.fill();
    if (e.slowFactor < 1) {
      ctx.strokeStyle = '#aef';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Emoji
    ctx.font = (e.size + 4) + 'px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(e.emoji, x, y + 1);

    // HP bar
    const barW = e.size * 1.6, barH = 3;
    const hpR = e.hp / e.maxHP;
    ctx.fillStyle = '#400';
    ctx.fillRect(x - barW/2, y - e.size - 6, barW, barH);
    ctx.fillStyle = hpR > 0.5 ? '#4c4' : '#c44';
    ctx.fillRect(x - barW/2, y - e.size - 6, barW * hpR, barH);
  }
}

function drawProjectiles() {
  for (const p of projectiles) {
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(p.x - 1, p.y - 1, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawParticles() {
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3 * alpha, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawFloatingTexts() {
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  for (const ft of floatingTexts) {
    const alpha = ft.life / ft.maxLife;
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 16px sans-serif';
    ctx.fillStyle = '#fd0';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 3;
    ctx.strokeText(ft.text, ft.x, ft.y);
    ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.globalAlpha = 1;
}

function drawUI(W, H) {
  // Top bar background
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(0, 0, W, 40);

  // Menu button
  const menuBtn = getMenuBtn();
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  roundRect(ctx, menuBtn.x, menuBtn.y, menuBtn.w, menuBtn.h, 6);
  ctx.fill();
  ctx.font = '16px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fff';
  ctx.fillText('‚ò∞', menuBtn.x + menuBtn.w / 2, menuBtn.y + menuBtn.h / 2);

  // Gold
  ctx.font = 'bold 16px sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fd0';
  ctx.fillText('üí∞ ' + gold, menuBtn.x + menuBtn.w + 8, 20);

  // Wave info
  ctx.textAlign = 'center';
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 15px sans-serif';
  const waveText = wave === 0 ? 'ÂáÜÂ§áÂºÄÂßã' : 'Ê≥¢Êï∞ ' + wave + '/' + TOTAL_WAVES;
  ctx.fillText(waveText, W / 2, 20);

  // Speed buttons
  const speedBtns = getSpeedButtons();
  for (const btn of speedBtns) {
    const isActive = Math.abs(gameSpeed - btn.speed) < 0.01;
    ctx.fillStyle = isActive ? 'rgba(255,200,50,0.7)' : 'rgba(255,255,255,0.2)';
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 6);
    ctx.fill();
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = isActive ? '#000' : '#fff';
    ctx.fillText(btn.label, btn.x + btn.w/2, btn.y + btn.h/2);
  }

  // Start wave button
  if (!waveActive && wave < TOTAL_WAVES && gameState === 'playing') {
    const btn = getStartWaveBtn();
    ctx.fillStyle = 'rgba(50,200,50,0.7)';
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 8);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1.5;
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 8);
    ctx.stroke();
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#fff';
    ctx.fillText('ÂºÄÂßãÁ¨¨ ' + (wave + 1) + ' Ê≥¢', btn.x + btn.w/2, btn.y + btn.h/2);
  }

  // Bottom bar
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(0, H - 100, W, 100);

  // Defender cards
  const cards = getDefenderCards();
  for (let i = 0; i < DEFENDER_TYPES.length; i++) {
    const dt = DEFENDER_TYPES[i];
    const c = cards[i];
    const canAfford = gold >= dt.cost;
    const isSelected = selectedDefender === i;

    ctx.fillStyle = isSelected ? 'rgba(255,200,50,0.6)' : (canAfford ? 'rgba(255,255,255,0.15)' : 'rgba(100,100,100,0.2)');
    roundRect(ctx, c.x, c.y, c.w, c.h, 8);
    ctx.fill();
    ctx.strokeStyle = isSelected ? '#fd0' : (canAfford ? 'rgba(255,255,255,0.3)' : 'rgba(100,100,100,0.3)');
    ctx.lineWidth = isSelected ? 2 : 1;
    roundRect(ctx, c.x, c.y, c.w, c.h, 8);
    ctx.stroke();

    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(dt.emoji, c.x + c.w/2, c.y + 24);

    ctx.font = '11px sans-serif';
    ctx.fillStyle = canAfford ? '#fff' : '#888';
    ctx.fillText(dt.name, c.x + c.w/2, c.y + 48);

    ctx.font = 'bold 12px sans-serif';
    ctx.fillStyle = canAfford ? '#fd0' : '#844';
    ctx.fillText('üí∞' + dt.cost, c.x + c.w/2, c.y + 66);
  }
}

function drawEndScreen(title, color, subtitle) {
  const W = getW(), H = getH();
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, W, H);

  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = color;
  ctx.fillText(title, W/2, H/2 - 30);

  ctx.font = '20px sans-serif';
  ctx.fillStyle = '#ddd';
  ctx.fillText(subtitle, W/2, H/2 + 20);

  ctx.font = '16px sans-serif';
  ctx.fillStyle = '#aaa';
  ctx.fillText('ÁÇπÂáªÂ±èÂπïËøîÂõûËèúÂçï', W/2, H/2 + 60);
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// --- Save / Load (localStorage) ---
const SAVE_KEY = 'campDefenseSave';
const SAVE_INTERVAL = 3; // auto-save every 3 seconds
let saveTimer = 0;

function saveGame() {
  if (gameState === 'menu') return;
  const data = {
    gold, campHP, wave, waveActive,
    waveEnemiesSpawned, waveEnemiesTotal, spawnTimer,
    gameSpeed, gameState, allWavesDone,
    levelId: currentLevel.id,
    themeId: currentTheme.id,
    defenders: defenders.map(d => ({
      col: d.col, row: d.row,
      typeId: d.type.id,
      level: d.level,
      attackTimer: d.attackTimer,
      angle: d.angle,
    })),
    enemies: enemies.map(e => ({
      x: e.x, y: e.y, hp: e.hp, maxHP: e.maxHP,
      speed: e.speed, color: e.color, reward: e.reward,
      size: e.size, emoji: e.emoji, name: e.name,
      slowTimer: e.slowTimer, slowFactor: e.slowFactor,
      targetX: e.targetX, targetY: e.targetY,
    })),
  };
  try { localStorage.setItem(SAVE_KEY, JSON.stringify(data)); } catch(e) {}
}

function loadGame() {
  let raw;
  try { raw = localStorage.getItem(SAVE_KEY); } catch(e) { return false; }
  if (!raw) return false;
  let data;
  try { data = JSON.parse(raw); } catch(e) { return false; }

  // Restore level and theme
  if (data.levelId) {
    const lvIdx = LEVELS.findIndex(l => l.id === data.levelId);
    if (lvIdx >= 0) { selectedLevel = lvIdx; currentLevel = LEVELS[lvIdx]; TOTAL_WAVES = currentLevel.waves; }
  }
  if (data.themeId) {
    const thIdx = BG_THEMES.findIndex(t => t.id === data.themeId);
    if (thIdx >= 0) { selectedBgTheme = thIdx; currentTheme = BG_THEMES[thIdx]; }
  }

  gold = data.gold;
  campHP = data.campHP;
  wave = data.wave;
  waveActive = data.waveActive;
  waveEnemiesSpawned = data.waveEnemiesSpawned;
  waveEnemiesTotal = data.waveEnemiesTotal;
  spawnTimer = data.spawnTimer || 0;
  gameSpeed = data.gameSpeed;
  gameState = data.gameState;
  allWavesDone = data.allWavesDone;
  selectedDefender = null;
  selectedPlacedDefender = null;
  projectiles = [];
  particles = [];
  floatingTexts = [];

  // Restore defenders with type reference
  defenders = (data.defenders || []).map(d => {
    const dt = DEFENDER_TYPES.find(t => t.id === d.typeId);
    if (!dt) return null;
    const sc = gridToScreen(d.col, d.row);
    return {
      col: d.col, row: d.row,
      x: sc.x, y: sc.y,
      type: dt,
      level: d.level || 1,
      attackTimer: d.attackTimer || 0,
      angle: d.angle || 0,
    };
  }).filter(Boolean);

  // Restore enemies
  enemies = (data.enemies || []).map(e => ({
    x: e.x, y: e.y, hp: e.hp, maxHP: e.maxHP,
    speed: e.speed, color: e.color, reward: e.reward,
    size: e.size, emoji: e.emoji, name: e.name,
    slowTimer: e.slowTimer || 0, slowFactor: e.slowFactor || 1,
    targetX: e.targetX, targetY: e.targetY,
  }));

  return true;
}

function clearSave() {
  try { localStorage.removeItem(SAVE_KEY); } catch(e) {}
}

function resetGame() {
  goToMenu();
}

// --- Auto-load save on startup ---
if (!loadGame()) {
  gameState = 'menu';
}

// --- Main loop ---
let lastTime = 0;
function gameLoop(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame((time) => { lastTime = time; gameLoop(time); });
</script>
</body>
</html>
